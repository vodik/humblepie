#!/usr/bin/env bash
###############################################################################
### thanks to:
### JavaAtom <faustian.merula@gmail.com>: filename generation for Introversion
### kevlarman <>: filenames for hib 1, 2
###
###############################################################################
## covered bundles:
##  4, 5, frozensynapse, introversion/1/2(maybe?)

rchome="${XDG_CONFIG_HOME}/humblepie"
if (( EUID == 0 )); then
  printf "%s%s\n\t%s"  "You are running this script as root! " \
    "This is potentially dangerous!" \
    "Continue? (y/N): "
  read -r rootreply

  [[ ${rootreply} =~ "[yY]??" ]] && {

    if [[ ! -f "${rcfile}" ]]; then
      rchome="/etc/humblepie"
      [[ ! -d "${rchome}" ]] || mkdir -p "${rchome}"
    fi

  }
fi

rcfile="${rchome}/humblepie.rc"
if [[ -r "${rcfile}" ]]; then
  . "${rcfile}"
elif [[ -f "${rcfile}" ]]; then
  echo "Bad permissions on ${rcfile}!"
else
  echo "No config file detected!"
fi

## check for automagic, turn on verbosity by default
(( automagic )) && verbose=1

if (( verbose )); then
  printf "%s\n\t%s\n\t%s\n" "Verbose reporting is on!" \
    "Run this program again with -x no and -v no to turn it off." \
    "Alternatively, use ${rcfile} to pre-configure all settings"

  verbose() {
      local info="$1"; shift
      declare -a mesg
      for a in "$@"; do
        mesg+=("$a")
      done
      printf "%s\t%s\n" "==> $(gettext "${info}":)" "${mesg[@]}"
  } >&2
  broken() { : } &>/dev/null
else
  broken() {
    local info="$1"; shift
    printf "%s\n\t%s\n" "==> Something is wrong..." \
      "Try again with -v\n" \
      "PROBLEM: ${info[@]}" "$@"
    exit 1
  } >&2
  verbose() { : } &>/dev/null
fi

check_key() {
  ## this needs to be opened up a bit to check keys manually specified on cli
  local k="${!hib_bundle}"
  [[ -z "${!k}" ]] && {
    broken "Unspecified key."
    verbose "ERROR" "hib_bundle is not specified.\n" \
      "\tSpecify the bundle you would like to use with -b [bundle]"
    exit 1
  }
    for v in "${!bundlekeys[@]}"; do
      [[ "${v}" == "${!k}" ]] && {
        hib_key="${v}"
      }
    done
}

check_arch() {
  if [[ -n "${hib_arch}" ]]; then
    [[ "${hib_arch}" =~ "i.86" || "${hib_arch}" == "x86_64" ]] || {
      broken "Bad architecture."
      verbose "WARNING" "Invalid value for hib_arch.\n" \
        "\tValid values are i386, i686, x86_64" \
        "\t\`uname -m\` should return the correct information."
      [[ "${automagic}" == "y" ]] && {
        hib_arch="$(uname -m)"
        verbose "INFO" "Using ${hib_arch} instead..."
      }
    }
  else 
    broken "Unspecified architecture."
    verbose "WARNING" "Architecture has not been specified.\n" \
      "\tPlease specify it with -a \`uname -m\`"
    [[ "${automagic}" == "y" ]] && {
      hib_arch="$(uname -m)"
      verbose "INFO" "Using ${hib_arch} instead..."
    }
  fi
}

check_dir() {
  local d="$1"
  if [[ -n "${d}" && -d "${d}" ]]; then
    [[ -w "${d}" ]] || {
      broken "Bad directory."
      verbose "ERROR" "${d} does not exist or is not writable!"
      [[ "${automagic}" == "y" && -w "$PWD"]] && {
        case "${d}" in
          hib_dir)
            hib_dir="$PWD/humbleindiebundle/"
            verbose "INFO" "Using ${hib_dir} instead..."
            d="hib_dir"
            ;;
          hib_torrent_dir)
            hib_torrent_dir="$PWD/humbleindiebundle/torrents/"
            verbose "INFO" "Using ${hib_torrent_dir} instead..."
            d="hib_torrent_dir"
            ;;
          *)
            verbose "ERROR" "${d} should only be hib_dir or hib_torrent_dir!"
            exit 1
            ;;
        esac
        mkdir -p "${!d}"
      }
    }
  else
    broken "Unspecified directory."
    verbose "WARNING" "No download directory specified.\n" \
      "\tUsing current directory instead..."
    directory="$PWD"
  fi
}

dl_game() {
  local uri
  # uri="$(curl -s http://www.humblebundle.com/downloads?key="${!hib_key}" \
  #   | grep "${game}")"
  case "${dl_method}" in
    # torrent)
    #   [[ -x "$(type -p ${torrent_bin})" ]] || {
    #     broken "${torrent_bin} not found."
    #     verbose "ERROR" "${torrent_bin} executable not found!" \
    #       "Please install ${torrent_bin}."
    #     exit 1
    #   }
    #     uri="${uri##*data-bt\=\'}"
    #     uri="${uri%%\'*}" 
    #     verbose "INFO" "To resume this download later run:" \
    #       "\`${torrent_bin} ${dl_opts} ${game}.torrent\`"
    #     [[ ! -f "${hib_torrent_dir}/${game}.torrent" ]] && {
    #       verbose "INFO" "Downloading ${hib_game}.torrent."
    #       curl -o "${hib_torrent_dir}/${game}.torrent" "${uri}"
    #     }
    #     (cd "${hib_torrent_dir}" && {
    #       verbose "INFO" "Downloading ${hib_game}."
    #       "${torrent_bin}" "${dl_opts}" "${game}.torrent"
    #     })
    #     ;;
    http)
      uri="http://files.humblebundle.com/${hib_game}?key=${hib_key}"
      [[ -f "${hib_dir}/${hib_game}.part" ]] && {
        verbose "INFO" "Downloading ${hib_game}"
        curl -o "${hib_dir}/${hib_game}.part" "${curl_dl_opts}" "${uri}"
      }
      ;;
    *) 
      broken "No download method specified."
      verbose "ERROR" "Specify download method with -t [type]"
      exit 1
  esac
}

get_uri() {
  ## takes hib_game and hib_key, slots it into link to get valid downloads
  local game="$1"
  local key="$2"
  ## trying to save these files to avoid redownloading
  local list="${key}.txt"
  if [[ -n "${use_torrent}" ]]; then
  # uri="$(curl -s http://www.humblebundle.com/downloads?key="${!hib_key}" \
    ## this is index.html of the downloads page for specified key
  fi
}

get_list() {
  ## this is a list of raw filenames and should be grabbed in 2 cases:
  ## if this file does not already exist, grab it
  ## if the updater is run, grab all the files again
  ## clobber this file, the old version is always useless
  local k="$1"
  lynx -dump http://www.humblebundle.com/downloads?key="${k}" |
    grep files|grep -v webseed|cut -d'/' -f4|cut -d'?' -f1>"${k}.txt"
}

download_file() {
  # download command
  local dlcmd=$1
  # URL of the file
  local url=$2
  # destination file
  local file=$3
  # temporary download file, default to last component of the URL
  local dlfile="${url##*/}"

  # replace %o by the temporary dlfile if it exists
  if [[ $dlcmd = *%o* ]]; then
    dlcmd=${dlcmd//\%o/\"$file.part\"}
    dlfile="$file.part"
  fi
  # add the URL, either in place of %u or at the end
  if [[ $dlcmd = *%u* ]]; then
    dlcmd=${dlcmd//\%u/\"$url\"}
  else
    dlcmd="$dlcmd \"$url\""
  fi

  local ret=0
  eval "$dlcmd || ret=\$?"
  if (( ret )); then
    [[ ! -s $dlfile ]] && rm -f -- "$dlfile"
    return $ret
  fi

  # rename the temporary download file to the final destination
  if [[ $dlfile != "$file" ]]; then
    mv -f "$SRCDEST/$dlfile" "$SRCDEST/$file"
  fi
}


check_sum() {
  ## verify how to use md5sum properly to prevent printing filename or `-'
  local g="$1"
  [[ "${check_sum}" == "y" ]] && {
    hib_game_md5sum="$(md5sum "${g}")"
    [[ "${hib_game_md5sum}" == "${hib_md5[$g]" ]] || {
      broken "MD5 did not match."
      verbose "ERROR" "${hib_game_md5sum} does not match ${hib_md5[$g]}"
    }
    verbose "INFO" "${hib_game_md5sum} == ${hib_md5[$g]}"
    verbose "INFO" "MD5 for ${g} was correct."
  }
}

main() {
  check_arch "${hib_arch}"
  check_key "${hib_bundle}"
  check_dir "${hib_dir}"
  [[ "${dl_method}" == "torrent"  ]] && {
    check_dir "${hib_torrent_dir}"
  }
  # sanitize_name "${hib_game}"
  # dl_game "${dl_cmd}" "${uri}" "${hib_game}"
  # check_sum "${hib_game}"
}

main

# sanitize_name() {
#   case "${hib_key}" in
#     ## use this to loop through the bundle arrays and start fuckin' shit up
#     ## set my important values to variables and kick to the downloader
#     hib_1_key) hib_1;;
#     hib_2_key) hib_2;;
#     hib_3_key) hib_3;;
#     hib_4_key) hib_4;;
#     hib_5_key) hib_5;;
#     hib_android1_key) hib_android1;;
#     hib_android2_key) hib_android2;;
#     hib_botanicula_key) hib_botanicula;;
#     hib_frozenbyte_key) hib_frozenbyte;;
#     hib_frozensynapse_key) hib_frozensynapse;;
#     hib_introversion_key) hib_introversion;;
#     hib_mojam_key) hib_mojam;;
#     hib_voxatron_key) hib_voxatron;;
#   esac
# }

# vim: ft=sh sw=2 sts=2 et
