#!/usr/bin/env bash
# vim: ft=sh sw=2 sts=2 et
###############################################################################
### v0.3.3
### Copyright (c) 2012 Josh McGee
### 
### Permission is hereby granted, free of charge, to any person obtaining a 
### copy of this software and associated documentation files (the "Software"),
### to deal in the Software without restriction, including without limitation 
### the rights to use, copy, modify, merge, publish, distribute, sublicense, 
### and/or sell copies of the Software, and to permit persons to whom the 
### Software is furnished to do so, subject to the following conditions:
### 
### The above copyright notice and this permission notice shall be included in 
### all copies or substantial portions of the Software.
### 
### THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
### IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
### FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
### THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
### LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
### FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
### DEALINGS IN THE SOFTWARE.
###
###############################################################################

## comments starting with a single octothorpe are experimental code
## more than one octothorpe signifies detail or instructional comments


## extglob is useful for matching with @()
shopt -s extglob
version="v0.3.3"

## if verbose is on, define verbose(). if off, define broken()
## this way, testing for verbose is only done a single time
## probably a better way to do this, but we'll get around to it later
messaging() {
  if (( verbose > 0 )); then
    printf "%s\n" "Verbose reporting is on!"
    verbose() {
      ## verbose has no special return value associated with it
      ## WARNING: return 2; ERROR: return 1; else return 0
      printf "==> %s:\t%s\n" "$1" "${@:2}"
    } >&2
    broken() { false; } &>/dev/null
  else
    broken() {
      ## broken() always returns 1 because we _probably_ want to exit 
      printf "==> %s\n\t%s\t%s %s\n" "Something is wrong..." \
        " Try again with -v." "PROBLEM: " "$1" "${@:2}"
      return 1
    } >&2
    verbose() { false; } &>/dev/null
  fi
}

check_root() {
  (( EUID == 0 )) && {
    ## check if they used root on purpose
    if  (( asroot > 0 )); then
      verbose="1"
      ## they're already root at this point, so further checking is moot
      dir_rc="/etc/humblepie"
    else
      echo "Running as root requires -r!"
      exit
    fi
  }
}

write_default_rc () {
  mkdir -p "$dir_rc"
  cat >"$rcfile" <<"EOF"
# hibkey_1="foobar"
# hibkey_2="foobar"
# hibkey_3="foobar"
# hibkey_4="foobar"
# hibkey_5="foobar"
# hibkey_android1="foobar"
# hibkey_android2="foobar"
# hibkey_botanicula="foobar"
# hibkey_frozenbyte="foobar"
# hibkey_frozensynapse="foobar"
# hibkey_introversion="foobar"
# hibkey_mojang="foobar"
# hibkey_voxatron="foobar"

# dir_hib="${HOME}/humbleindiebundle"
# dir_hib_torrent="${dir_hib}/torrents" # not implemented
## set these to 1 to enable
## check md5sum of downloads
check_md5=1
## spit out more detailed info, warnings, and errors
verbose=0
## turn on automatic checking/downloading updates; not implemented
# update=0
EOF
  echo "Created default config in ${dir_rc%/}" && exit
}

check_dir() {
  ## pick a directory for config to live in
  [[ "$dir_rc" ]] || dir_rc="${HOME}/.config/humblepie"
  rcfile="${dir_rc%/}/humblepie.rc"
  [[ ! -f "$rcfile" ]] && write_default_rc
  . "$rcfile"

  for dir in "${!dir_@}"; do
    case "$dir" in
      dir_hib)
        [[ -d "${dir_hib%/}" && -w "${dir_hib%/}" ]] || {
          dir_hib="${HOME}/humbleindiebundle"
          verbose "INFO" "Using $dir_hib instead..."
          mkdir -p $dir_hib
        } ;;
      dir_hib_torrent)
        [[ -d "${dir_hib_torrent%/}" && -w "${dir_hib_torrent%/}" ]] || {
          dir_hib_torrent="${HOME}/humbleindiebundle/torrents"
          verbose "INFO" "Using $dir_hib_torrent instead..."
          mkdir -p $dir_hib_torrent
        } ;;
      # dir_install)
      #   [[ -d "${dir_install%/}" && -w "${dir_install%/}" ]] || {
      #   dir_install="${HOME}/humbleindiebundle/install"
      #   verbose "INFO" "Using $dir_install instead..."
      #   mkdir -p $dir_install
      # } ;;
    esac
  done
}

## kudos to Riviera on #bash for help with this one o/
generate_list() {
  unset IFS links list link dl
  local game pattern; declare -Ag links; declare -ag list

  ## needs to start with http obviously, then...
  ## ...strip out the ugly ubuntu link because lolcoupons...
  ## ...and only use links with key= in them
  # pattern='http!(*ubuntu*)key=*'
  while read -r link; do
    ## check the line, make sure it's a proper link, then add it to list
    link="${link#* }"
    ## seems to strip important links =[
    [[ "$link" == *files* ]] &&
      list+=("$link")
        ## read in the links dump
  done < <(links -html-numbered-links 1 -dump \
            "https://www.humblebundle.com/downloads?key=${hib_key}")

  for dl in "${list[@]}"; do
    file="${dl#*files*/}"
    ## strip everything after '?key=' to get a filename
    file="${file%%\?*}"
    links["$file"]="$dl"
  done
}

search_list() {
  unset dl slist; declare -ag slist; declare -Ag slinks

  for s in "${!links[@]}"; do
    [[ "${s,,}" == +(*${search,,}*) ]] && slist+=("$s")
  done

  [[ "${slist[@]}" ]] || {
    broken "No files matched the search." || {
      verbose "ERROR" "The search was unsuccessful.\n" \
        "\tPlease verify you specified a key or bundle and" \
        "spelled the search term correctly."
      return 1
    }
  }

  for dl in "${slist[@]}"; do
    slinks["$dl"]="${links[$dl]}"
  done
}

auto_dl_game () {
  unset downloads; declare -ag downloads

  case "$1" in
    single)
      downloads[0]="$hib_game"
      dest["$hib_game"]="${dir_hib}/$hib_game"
      ;;
    search)
      user_list "${slist[@]}"
      ;;
    *)
      user_list "${!links[@]}"
      ;;
  esac

  ## loop through the choices
  for fn in "${downloads[@]}"; do
    ## make sure the game doesn't already exist
    if [[ -f "${dest[$fn]}" ]]; then
      verbose "WARNING" "$fn already exists! Skipping..."
    else
      ## then download it!
      verbose "INFO" "Downloading $fn..."
      curl -# -o "${dest[$fn]}" "${links[$fn]}" &&
        verbose "INFO" "Finished downloading ${fn}!"
    fi
  done

  (( check_md5 > 0 )) && check_sum
}

user_list() {            
  unset dest; declare -Ag dest
  PS3="Select files by number, continue with 0: "

  select choice in "$@"; do
    [[ "$choice" ]] || break
    ## store each choice in an array
    downloads+=("$choice")
    ## now populate this associative array last using index of ${downloads[@]}
    dest[$choice]="${dir_hib%/}/${downloads[@]:(-1)}"
  done
}

check_sum() {
  unset md5 sums dl; local md5; declare -a sums

  for dl in "${list[@]}"; do
    [[ "$dl" == *downloads*#* ]] && {
      cksum="${dl#*#}"
      [[ "$cksum" ]] && sums+=("$cksum")
    }
  done

  for file in "${downloads[@]}"; do
    ## store the md5 hash
    md5="$(md5sum <"${dir_hib%/}/$file")"
    ## md5sum has a really irritating habit to print "cksum   filename"
    ## strip everything from first space to end of var
    md5="${md5%% *}"
    ## can't guarantee mixed case will ever match
    ## capitalize everything, sums may be mixed case (i think)
    ## potential to result in flawed success?
    ## without case modification, potential for false negatives?
    for sum in "${sums[@]}"; do
      [[ "${md5^^}" == "${sum^^}" ]] && {
        success="1"
        verbose "INFO" "The md5 for $g is okay!"
        break
      }
    done
    (( success < 1 )) && broken "Checksums did not match." ||
       verbose "INFO" "The md5 for $g ($md5) did not match $sum"
  done
}

usage() {
  printf "humblepie %s\n" "$version"
  echo
  printf "Configuration should be done with ~/.config/humblepie/humblepie.rc\n"
  printf -- "Usage: %s [options]\n" "${0%%*/}"
  echo
  printf -- "Options:\n"
  printf -- " -b <name>   Choose the bundle specified in config\n"
  printf -- " -C <path>   Specify an alternate config file\n"
  printf -- " -d <dir>    Set the download directory\n"
  printf -- " -f <file>   Specify a file to download: must be full filename\n"
  printf -- " -k <key>    Specify a key manually: overrides -b\n"
  printf -- " -s <term>   Case-insensitive search for files in bundle: requires -b or -k, overrides -g\n"
  printf -- " -c          Enable md5 checking\n"
  printf -- " -h          Print this help\n"
  printf -- " -r          Enable operation as root, for system-wide installations *NOT RECOMMENDED*\n"
  printf -- " -v          Turn on verbose reporting for info, warnings, errors\n"
  echo
  printf -- "\tEXAMPLES:\n"
  echo
  printf -- "\tUsing hibkey_5, set download directory to ${HOME}/hib and search for \`psycho':\n"
  printf -- "\t%s -b 5 -d ${HOME}/hib -s psycho\n" "${0%%*/}"
  echo
  printf -- "\tUsing bundle key 0a1b2c3d, download amnesia_tdd-1.2.1-3.sh without prompting:\n"
  printf -- "\t%s -k 0a1b2c3d -g amnesia_tdd-1.2.1-3.sh\n" "${0%%*/}"
  echo
}
run() {
check_root
check_dir
OPTIND=1
while getopts ":b:d:f:k:s:chrv" opt; do
  case "$opt" in
    \?) ## usage, exit with error
      echo "Invalid option specified."
      usage
      exit 1
      ;;
    h) ## print usage
      usage
      exit
      ;;
    r) ## turn on root, for systemwide installs
      asroot=1
      ;;
    C) ## set location to config file
      unset rcfile
      rcfile="$OPTARG"
      . "$rcfile"
      ;;
    d) ## set the download dir
      unset dir_hib
      dir_hib="${OPTARG%/}"
      ;;
    b) ## just pick the bundle with the rcfile
      unset hib_key
      hib_key="hibkey_$OPTARG"
      hib_key="${!hib_key}"
      ;;
    k) ## specify a key manually
      unset hib_key
      hib_key="$OPTARG"
      ;;
    f) ## pick a game to download
      unset dl_arg
      dl_arg="single"
      hib_game="$OPTARG"
      ;;
    s) ## case insensitive searching
      unset dl_arg hib_game
      dl_arg="search"
      search="$OPTARG"
      ;;
    c) ## check_game should verify md5
      check_md5=1
      ;;
    v) ## enable verbosity
      verbose=1
      ;;
    # i) ## not implemented
    #   dir_install="${OPTARG}"
    #   ;;
    # m) ## set download method; not implemented
    #   case "${OPTARG}" in
    #     t|torrent) dl_method="torrent"
    #       ;;
    #     h|http) dl_method="http"
    #       ;;
    #   esac
    #   ;;
    # t) ## set the hib_torrent_dir; not implemented
    #   hib_torrent_dir="${OPTARG}"
    #   ;;
  esac
done
messaging
generate_list
[[ "$search" ]] && search_list
auto_dl_game "$dl_arg"
}

if [[ -z "$@" ]]; then
  usage && exit 1
fi
run "$@"
