#!/usr/bin/env bash
###############################################################################
### thanks to:
### JavaAtom <faustian.merula@gmail.com>: filename generation for Introversion
###
###
###############################################################################
## covered bundles:
##  4, 5, frozensynapse, introversion(maybe?)
## kevlarman has 2 more bundles
rcfile="${XDG_CONFIG_HOME}/humblepie.rc"
[[ -f "${rcfile}" ]] && . "${rcfile}"


OPTIND=1
while getopts "a:b:d:g:i:k:o:r:t:u:U:v:chIV" opt; do
  case "$opt" in
    a) ## check_arch will make sure i get a value i can work with
      hib_arch="${OPTARG}"
      ;;
    b) ## check_key should successfully verify that keys match
      hib_bundle="hib_${OPTARG}_key"
      ;;
    c) ## check_game should verify md5, not implemented
      check_sum="y"
      [[ -n "${OPTARG}" ]] && {
        sanitize_name "${OPTARG}"
        check_sum "${hib_game}"
        exit 0
      }
      ;;
    d) ## set the download/game dir
      hib_dir="${OPTARG}"
      ;;
    g) ## this should just store the game name
      # for now, i plan to have another function that kicks off the rest
      hib_game="${OPTARG}"
      ;;
    h\?) : ## print usage
      ;;
    i) ## not implemented
      # install_dir="${OPTARG}"
      ;;
    I) : ## not implemented, maybe never will but seems simplish
      # interactive="y"
      ;;
    k) ## specify a key manually, not implemented
      hib_key="${OPTARG}"
      ;;
    m) ## set download method
      case "${OPTARG}" in
        t|torrent) dl_method="torrent"
          ;;
        h|http) dl_method="http"
          ;;
      esac
      ;;
    o) ## set options for download; these MUST be quoted
      dl_opts="${OPTARG}"
      ;;
    r|R|u|U) : ## uninstall the game; essentially, just rm -rf the install dir
      # which means i need some way to FIND the install dir if not in rcfile
      ;;
    t) ## set the hib_torrent_dir
      hib_torrent_dir="${OPTARG}"
      ;;
    U) ## check for updates and download if possible
      # if [[ "${OPTARG}" ]]; then
      #   hib_game="${OPTARG}"
      #   automagic="y"
      #   updater
      # else
      #   updater "$0"
      # fi
      ;;
    v) ## enable verbosity
      [[ "${OPTARG}" != "no" ]] &&
        verbose="y"
      ;;
    V) : ## print version info
      ;;
    x) 
      [[ "${OPTARG}" != "no" ]] &&
        automagic="y"
      ;;
  esac
done

[[ "${automagic}" == "y" ]] && verbose=y

if [[ ${verbose} == "y" ]]; then
  printf "%s\n\t%s\n\t%s\n" "Verbose reporting is on!" \
    "Run this program again with -x no and -v no to turn it off." \
    "Alternatively, use ${rcfile} to pre-configure all settings"

  verbose() {
      local info="$1"; shift
      declare -a mesg
      for a in "$@"; do
        mesg+=("$a")
      done
      printf "%s\t%s\n" "==> $(gettext "${info}":)" "${mesg[@]}"
  } >&2
  broken() { : } &>/dev/null
else
  broken() {
    local info="$1"; shift
    printf "%s\n\t%s\n" "==> Something is wrong..." \
      "Try again with -v\n" \
      "PROBLEM: ${info[@]}" "$@"
    exit 1
  } >&2
  verbose() { : } &>/dev/null
fi

check_key() {
  ## this needs to be opened up a bit to check keys manually specified on cli
  local k="${!hib_bundle}"
  [[ -z "${!k}" ]] && {
    broken "Unspecified key."
    verbose "ERROR" "hib_bundle is not specified.\n" \
      "\tSpecify the bundle you would like to use with -b [bundle]"
    exit 1
  }
    for v in "${!bundlekeys[@]}"; do
      [[ "${v}" == "${!k}" ]] && {
        hib_key="${v}"
      }
    done
}

check_arch() {
  if [[ -n "${hib_arch}" ]]; then
    [[ "${hib_arch}" =~ "i.86" || "${hib_arch}" == "x86_64" ]] || {
      broken "Bad architecture."
      verbose "WARNING" "Invalid value for hib_arch.\n" \
        "\tValid values are i386, i686, x86_64" \
        "\t\`uname -m\` should return the correct information."
      [[ "${automagic}" == "y" ]] && {
        hib_arch="$(uname -m)"
        verbose "INFO" "Using ${hib_arch} instead..."
      }
    }
  else 
    broken "Unspecified architecture."
    verbose "WARNING" "Architecture has not been specified.\n" \
      "\tPlease specify it with -a \`uname -m\`"
    [[ "${automagic}" == "y" ]] && {
      hib_arch="$(uname -m)"
      verbose "INFO" "Using ${hib_arch} instead..."
    }
  fi
}

check_dir() {
  d="$1"
  if [[ -d "${d}" ]]; then
    [[ -w "${d}" ]] || {
      broken "Bad directory."
      verbose "ERROR" "${d} does not exist or is not writable!"
      exit 1
      [[ "${automagic}" == "y" && -w "$PWD"]] && {
        case "${d}" in
          hib_dir)
            hib_dir="$PWD/humbleindiebundle/"
            verbose "INFO" "Using ${hib_dir} instead..."
            d="hib_dir"
            ;;
          hib_torrent_dir)
            hib_torrent_dir="$PWD/humbleindiebundle/torrents/"
            verbose "INFO" "Using ${hib_torrent_dir} instead..."
            d="hib_torrent_dir"
            ;;
          *)
            verbose "ERROR" "${d} should only be hib_dir or hib_torrent_dir!"
            exit 1
            ;;
        esac
        mkdir -p "${!d}"
      }
    }
  else
    broken "Unspecified directory."
    verbose "WARNING" "No download directory specified.\n" \
      "\tUsing current directory instead..."
    directory="$PWD"
  fi
}

dl_game() {
  local uri
  # uri="$(curl -s http://www.humblebundle.com/downloads?key="${!hib_key}" \
  #   | grep "${game}")"
  uri="http://www.humblebundle.com/downloads?key=${!hib_key}"
  uri="${uri##*$hib_game}"
  case "${dl_method}" in
    torrent)
      [[ -x "$(type -p ${torrent_bin})" ]] || {
        broken "${torrent_bin} not found."
        verbose "ERROR" "${torrent_bin} executable not found!" \
          "Please install ${torrent_bin}."
        exit 1
      }
        uri="${uri##*data-bt\=\'}"
        uri="${uri%%\'*}" 
        verbose "INFO" "To resume this download later run:" \
          "\`${torrent_bin} ${dl_opts} ${game}.torrent\`"
        [[ ! -f "${hib_torrent_dir}/${game}.torrent" ]] && {
          verbose "INFO" "Downloading ${hib_game}.torrent."
          curl -o "${hib_torrent_dir}/${game}.torrent" "${uri}"
        }
        (cd "${hib_torrent_dir}" && {
          verbose "INFO" "Downloading ${hib_game}."
          "${torrent_bin}" "${dl_opts}" "${game}.torrent"
        })
        ;;
    http)
      uri="${uri##*data-web\=\'}"
      uri="${uri%%\'*}" 
      [[ -f "${game}.part" ]] &&
        verbose "INFO" "Downloading ${hib_game}"
        curl -o "${hib_game}.part" "${http_dl_opts}" "${uri}"
      mv "${hib_game}.part" "${hib_dir}" ;;
    *) 
      broken "No download method specified."
      verbose "ERROR" "Specify download method with -t [type]"
      exit 1
  esac
}

check_sum(){
  local g="$1"
  [[ "${check_sum}" == "y" ]] && {
    hib_game_md5sum="$(md5sum "${hib_game}")"
    [[ "${hib_game_md5sum}" == "${hib_md5[$hib_game]" ]] || {
      broken "MD5 did not match."
      verbose "ERROR" "${hib_game_md5sum} does not match ${hib_md5[$hib_game]}"
    }
    verbose "INFO" "${hib_game_md5sum} == ${hib_md5[$hib_game]}"
    verbose "INFO" "MD5 for ${hib_game} was correct."
  }
}

main() {
  check_arch "${hib_arch}"
  check_key "${hib_bundle}"
  check_dir "${hib_dir}"
  [[ "${dl_method}" == "torrent"  ]] && {
    check_dir "${hib_torrent_dir}"
  }
  # sanitize_name "${hib_game}"
  dl_game "${hib_game}"
  check_sum "${hib_game}"
}

(( EUID )) && {
  printf "%s%s\n\t%s"  "You are running this script as root! " \
    "This is potentially dangerous!" \
    "Continue? (y/N): "
  read -r _rootuser
  [[ ${_rootuser} =~ "[yY]??" ]] && {
  main
  exit
  }
}

main

# sanitize_name() {
#   case "${hib_key}" in
#     ## use this to loop through the bundle arrays and start fuckin' shit up
#     ## set my important values to variables and kick to the downloader
#     hib_1_key) hib_1;;
#     hib_2_key) hib_2;;
#     hib_3_key) hib_3;;
#     hib_4_key) hib_4;;
#     hib_5_key) hib_5;;
#     hib_android1_key) hib_android1;;
#     hib_android2_key) hib_android2;;
#     hib_botanicula_key) hib_botanicula;;
#     hib_frozenbyte_key) hib_frozenbyte;;
#     hib_frozensynapse_key) hib_frozensynapse;;
#     hib_introversion_key) hib_introversion;;
#     hib_mojam_key) hib_mojam;;
#     hib_voxatron_key) hib_voxatron;;
#   esac
# }

# vim: ft=sh sw=2 sts=2 et
