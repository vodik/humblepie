#!/usr/bin/env bash
###############################################################################
### thanks to:
### JavaAtom <faustian.merula@gmail.com>: filename generation for Introversion
### kevlarman <>: filenames for hib 1, 2
###
###############################################################################
## covered bundles:
##  4, 5, frozensynapse, introversion/1/2(maybe?)

automagic=1
verbose=1
asroot=0
rcdir="${XDG_CONFIG_HOME}/humblepie"

(( EUID == 0 )) && {
  ## check if they used root on purpose
  if  (( ! asroot )); then
    ## if $rcfile doesn't exist, we're going to use /etc instead
    ## they're already root at this point, so further checking is moot
    [[ ! -f "$rcfile" ]] && rcdir="/etc/humblepie"
  fi
}

rcfile="$rcdir/humblepie.rc"
[[ -d "$rcdir" ]] || mkdir -p "$rcdir"
if [[ -r "$rcfile" ]]; then
  . "$rcfile"
elif [[ -f "$rcfile" ]]; then
  echo "Bad permissions on $rcfile!"
else
  echo "No config file detected!"
fi

## brilliant idea, if gettext doesn't exist just echo the args
## makepkg is some fantastic inspiration even if it's ugly
if [[ ! -x "$(type -p gettext)" ]]; then
  gettext() {
    echo "$@"
  }
## check for automagic, turn on verbosity by default
(( ! automagic )) && verbose=1

## if verbose is on, define verbose(). if off, define broken()
## this way, testing for verbose is only done a single time
## probably a better way to do this, but we'll get around to it later
if (( ! verbose )); then
  ## i would like to incorporate some gettext action in here
  printf "%s\n\t%s\n\t%s\n" "Verbose reporting is on!" \
    "Run this program again with -x no and -v no to turn it off." \
    "Alternatively, use $rcfile to pre-configure for $USER."

  verbose() {
    ## verbose has no special return value associated with it
    ## sometimes we call it to print extra info
    ## sometimes it prints errors. return accordingly
    local info="$1"; shift
    printf "%s\t%s\n" "==> $(gettext "$info": "$@")"
  } >&2
  ## probably unnecessary to do
  broken() { : } &>/dev/null
else
  broken() {
    ## broken() always returns 1 because we _probably_ want to exit 
    local mess="$1"; shift
    printf "%s\n\t%s\n" "==> $(gettext "Something is wrong..." \
      "Try again with -v\n" "PROBLEM: $mess" "$@")"
    return 1
  } >&2
  ## again, likely unnecessary
  verbose() { : } &>/dev/null
fi

check_key() {
  ## this needs to be opened up a bit to check keys manually specified on cli
  ## probably just accept $1, in fact that's what i'll do now
  ## so send "${!hib_bundle}" or the key from cli
  ## TODO: now figure out why i am verifying a key from cli
  ## those should only be specified because not in config yet
  # local k="${!hib_bundle}"
  local k="$1"
  local ret=0
  ## verify a key was sent, if empty cry about it
  [[ -z "$k" ]] && {
    broken "Unspecified key."
    verbose "ERROR" "hib_bundle is not specified.\n" \
      "\tSpecify the bundle you would like to use with -b [bundle]"
    ret=1
  }
  ## now loop through the keys and when a match is found, set hib_key
  ## only 1 key can be specified at a time
  ## only 1 match is ever possible
  for v in "${!bundlekeys[@]}"; do
    [[ "$v" == "$k" ]] && {
      hib_key="$v"
      ## i break just to end the loop as early as possible
      break
    }
    ret=2
  done
}

check_arch() {
  local arch="$1"
  ## make sure hib_arch is set; then...
  if [[ -n "$arch" ]]; then
    ## ensure its value is legal in my context or cry about it
    [[ "$arch" =~ "i.86" || "$arch" == "x86_64" ]] || {
      broken "Bad architecture."
      verbose "WARNING" "Invalid value for hib_arch.\n" \
        "\tValid values are i386, i686, x86_64" \
        "\t\`uname -m\` should return the correct information."

      ## TODO: find a better way to do the automagic things
      ## probably similar to the way we do verbose

      ## if automagic is on, set hib_arch to something i expect
      if (( automagic )); then
        hib_arch="$(uname -m)"
        verbose "INFO" "Using $hib_arch instead..."
      fi
    }
  else 
    ## so they never set hib_arch
    broken "Unspecified architecture."
    verbose "ERROR" "Architecture has not been specified.\n" \
      "\tPlease specify it with -a \`uname -m\`"

    ## but i can still try to set it to something sane
    if (( automagic )); then
      hib_arch="$(uname -m)"
      verbose "INFO" "Using $hib_arch instead..."
    else return 2
    fi

  fi
}

check_dir() {
  ## grab 1st arg
  local d="$1"
  ## make sure it's a directory
  if [[ -d "$d" ]]; then
    ## make sure it is r/w, or cry about it
    [[ -r "$d" && -w "$d" ]] || {
      broken "Bad directory."
      verbose "ERROR" "$d does not exist or is not writable!"
      ##if automagic, and current dir is writable, use it
      if (( automagic )) && [[ -r "$PWD" &&  -w "$PWD"]]; then

        ## TODO: does this need to be a case?

        case "$d" in
          hib_dir)
            hib_dir="$PWD/humbleindiebundle/"
            verbose "INFO" "Using $hib_dir instead..."
            d="hib_dir"
            ;;
          hib_torrent_dir)
            hib_torrent_dir="$PWD/humbleindiebundle/torrents/"
            verbose "INFO" "Using $hib_torrent_dir instead..."
            d="hib_torrent_dir"
            ;;
          rcdir)
            rcdir="$PWD/humblepie"
            verbose "INFO" "Using $rcdir instead..."
            d="rcdir"
            ;;
          *)
            verbose "ERROR" "Pass a proper value for \$d."
            return 1
            ;;
        esac
        mkdir -p "${!d}"
      fi
    }
  else
    broken "Unspecified directory."
    verbose "WARNING" "No download directory specified.\n" \
      "\tUsing current directory instead..."

    ## TODO: is this really necessary? should i set both dirs to this?
    ## maybe do it if automagic is on

    directory="$PWD"
  fi
}

get_uri() {
  ## TODO: generate link from this
  ## takes hib_game and hib_key, slots it into link to get valid downloads
  local game="$1"
  local key="$2"
  # uri="$(curl -s http://www.humblebundle.com/downloads?key="${!hib_key}" \
  local list="$key.txt"
  if [[ -n "$use_torrent" ]]; then
    ## this is index.html of the downloads page for specified key
  fi
}

get_list() {
  local k="$1"
  ## trying to save these files to avoid redownloading
  ## this is a list of raw filenames and should be grabbed in 2 cases:
  ## if this file does not already exist, grab it
  ## if the updater is run, grab all the files again
  ## clobber this file, the old version is always useless

  ## quick and dirty way to grab a complete list of files
  links -html-numbered-links 1 \
    -dump http://www.humblebundle.com/downloads?key="$k" |
    grep files|grep -v webseed|cut -d'/' -f4|cut -d'?' -f1>"$k.txt"
}

check_sum() {
  local game="$1"
  local list="$2"
  md5="$(md5sum "$1")"
  grep "$md5" "$list" || return 2
}

# vim: ft=sh sw=2 sts=2 et
