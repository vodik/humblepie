#!/usr/bin/env bash
# vim: ft=sh sw=2 sts=2 et
###############################################################################
### thanks to:
### JavaAtom <faustian.merula@gmail.com>: filename generation for Introversion
### kevlarman <>: filenames for hib 1, 2
###
###############################################################################
## covered bundles:
##  4, 5, frozensynapse, introversion/1/2(maybe?)

## comments starting with a single octothorpe are experimental code
## more than one octothorpe signifies detail or instructional comments


## extglob is useful for matching with @()
shopt -s extglob

## make gettext() a no-op if the binary is not executable
[[ ! -x "$(type -p gettext)" ]] && gettext() { echo "$@"; }
## if verbose is on, define verbose(). if off, define broken()
## this way, testing for verbose is only done a single time
## probably a better way to do this, but we'll get around to it later
if (( verbose )); then
  ## i would like to incorporate some gettext action in here
  printf "%s\n" "$(gettext "Verbose reporting is on!\n \
    \tRun this program again with -x and -v to turn it off.\n \
    \tAlternatively, use $rcfile to pre-configure for $USER.")"

  verbose() {
    ## verbose has no special return value associated with it
    ## sometimes we call it to print extra info
    ## sometimes it prints errors. return accordingly
    ## WARNING: return 2; ERROR: return 1; else return 0
    printf "%s\n" "==> $(gettext $1: $@:2)"
  } >&2
  ## define this as false so i can do `broken && cmd` and cmd..
  ## .. only executes if verbose() { false; }; otherwise..
  ## .. i can do `broken || cmd` if necessary
  ## probably unnecessary to do
  broken() { false; } &>/dev/null
else
  broken() {
    ## broken() always returns 1 because we _probably_ want to exit 
    printf "%s\n" "==> $(gettext "Something is wrong...\n \
      \tTry again with -v\n\tPROBLEM: $1 $@:2")"
    return 1
  } >&2
  ## same applies here as did to broken() { false; }
  ## again, likely unnecessary
  verbose() { false; } &>/dev/null
fi

check_root() {
  (( EUID )) && {
    ## check if they used root on purpose
    if  (( ! asroot )); then
      verbose="1"
      ## if expected $rcfile doesn't exist, we're going to use /etc instead
      ## they're already root at this point, so further checking is moot
      [[ -f "${dir_rc}/humblepie.rc" ]] || dir_rc="/etc/humblepie"
      rcfile="${dir_rc}/humblepie.rc"
    fi
  }
}

check_files () {
  check_dir
  check_root
  rcfile="${dir_rc}/humblepie.rc"
  if [[ -r "$rcfile" ]]; then
    . "$rcfile"
  else
    [[ -w "$dir_rc" ]] && cat >&1 >"$rcfile" <<'EOF'
# hibkey_1="foobar"
# hibkey_2="foobar"
# hibkey_3="foobar"
# hibkey_4="foobar"
# hibkey_5="foobar"
# hibkey_android1="foobar"
# hibkey_android2="foobar"
# hibkey_botanicula="foobar"
# hibkey_frozenbyte="foobar"
# hibkey_frozensynapse="foobar"
# hibkey_introversion="foobar"
# hibkey_mojang="foobar"
# hibkey_voxatron="foobar"

# dir_hib="${HOME}/humbleindiebundle"
# dir_hib_torrent="${dir_hib}/torrents"
## set these to 1 to enable
## allow running as root (for systemwide installations)
asroot=0
## test key for validity
check_key=1
## check md5sum of downloads
check_md5=1
## spit out more detailed info, warnings, and errors
verbose=0
## turn on automatic checking/downloading updates
# update=0
EOF
  echo "Created default config in $dir_rc" && exit 0
  fi

asroot="${asroot:=0}"
check_key="${check_key:=1}"
check_md5="${check_md5:=1}"
verbose=${verbose:-1}
}

in_array() {
  local i
  for i in "${@:2}"; do
    [[ $1 = "$i" ]] && return
  done
}

check_dir() {
  if [[ "$XDG_CONFIG_HOME" ]]; then
    dir_rc="${XDG_CONFIG_HOME}/humblepie"
  else
    dir_rc="${HOME}/.config/humblepie"
  fi
  case "${!dir_@}" in
    dir_hib)
      [[ -d "$dir_hib" && -w "$dir_hib" ]] || {
        d="${PWD}/humbleindiebundle/"
        verbose "INFO" "Using $d instead..."
        dir_hib="$d"
      } ;;&
    dir_hib_torrent)
      [[ -d "$dir_hib_torrent" && -w "$dir_hib_torrent" ]] || {
        d="${PWD}/humbleindiebundle/torrents/"
        verbose "INFO" "Using $d instead..."
        dir_hib_torrent="$d"
      } ;;&
    # dir_rc)
    #   [[ -d "$dir_rc" && -w "$dir_rc" ]] || {
    #     d="${confdir}/humblepie"
    #     verbose "INFO" "Using $d instead..."
    #     dir_rc="$d"
    #     rcfile="$dir_rc/humblepie.rc"
    #   } ;;
  esac
  for d in "${!dir_@}"; do
    [[ "${d}" ]] || mkdir -p "$d" 
  done
}

check_key() {
  ## grab the key
  # local k="$1" ret=0
  ## declare the array for keys
  declare -A bundlekeys
  ## expand all $hibkey_* variables from rcfile if they are set
  ## the quotes and @ are important for proper expansion
  for var in "${!hibkey_@}"; do
    ## this is an indirect expansion to test if any $hibkey_* expanded
    ## ${!var} will equal the value of each $hibkey_* in turn
    ## if hibkey_foo="barbazquux" then $var expands to "barbazquux"
    ## $var would be "hibkey_foo"
    ## ["hibkey_foo"]="barbazquux"
    # bundlekeys+=( ["${var##*_}"]="${var}" ) 
    # if [[ ${!bundlekeys@} ]]; then
    ## only populate array if there is a key defined
    [[ "${!var}" == "${!hib_key}" ]] && {
      ## if no key found, cry
      # broken "No keys discovered."
      # verbose "ERROR" "No keys configured.\n" \
      #   "\tPlease specify a key with -k [key] or in your user's config file."
      # return 1
    ## i'm storing these in an array for possible re-use
      k="${!var}"
      h="${var##*_}"
      bundlekeys+=(["$k"]="$h") 
    }
  done
  verbose "INFO" "${#bundlekeys[@]} keys found!"
}

## kudos to Riviera on #bash for help with this one o/
generate_list() {
  ## unset for safety; declare an associative array
  unset IFS links; declare -Ag links; declare -a list
  local game pattern
  pattern='http?(s)://!(support).humble*/?(downloads)*!(stats)'
  while read -r link; do
    ## check the line, make sure it's a proper link, then add it to list
    link="${link#* }"
    [[ "$link" == $pattern ]] && list+=("$link")
        ## read in the links dump
  done < <(links -html-numbered-links 1 -dump \
            "https://www.humblebundle.com/downloads?key=$1")
  for f in "${list[@]}"; do
    echo $f >>./foobar
  done
  exit
    # [[ "$link" == http://files.humblebundle.com/* ]] && {
    #   file="${link#*files*/}"
    #   ## strip everything after '?key=' to get a filename
    #   file="${file%%\?*}"
    #   links["$file"]="$link"
    # }
}

generate_md5() {
  local md5; declare -a sums; declare -ag files
  while read -r list; do
    ## the lines i want often start with numbers like `145. '
    ## so strip out everything up to and including the first space
    list="${list#* }"
    ## then it needs to be a file link
    [[ "$list" == http://files.humblebundle.com/* ]] && {
      file="${list#*files*/}"
      ## strip everything after '?key=' to get a filename
      file="${file%%\?*}"
      files+=("$file")
    }
    ## now make sure the line is a link that can contain an md5
    [[ "$list" = https://www.humblebundle.com/downloads?key=$1#* ]] && {
      ## strip everything before the md5sum out of it now
      md5="${list##*#}"
      ## sometimes the value is then an empty string, so ignore those
      ## and then there is this one errant link pointing at stats
      ## that's not an md5 (duh) so ignore it
      ## then we populate the sums array
      [[ "$md5" && "$md5" != "stats" ]] && sums+=("$md5")
      ## checksums immediately follow their associated game
      ## so far, this seems the simplest functional way to get things right
    }
  done < <(links -html-numbered-links 1 -dump \
            "https://www.humblebundle.com/downloads?key=$1")
  declare -Ag cksums
  local i=0
  ## now step through the array of filenames and assigning sums in order
  for filename in "${files[@]}"; do
    cksums[$filename]="${sums[$i]}"
    ((i++))
  done
}

dl_game () {
  declare -ag downloads
  declare -A dest
  select choice in "${!links[@]}" quit; do
    [[ "$choice" = quit ]] && break
    ## store each choice in an array
    downloads+=("$choice")
    ## now populate this associative array by using the last index of ${game[@]}
    dest[$choice]="${dir_hib}/${game[@]:(-1)}"
  done
  for t in "${downloads[@]}"; do
    if [[ -f "${dest[$t]}" ]]; then
      echo "$t already exists!"
    else
      echo "Downloading $t..."
      curl -# -o "${dest[$t]}" "${links[$t]}"
      echo "Finished downloading ${t}!"
    fi
  done
}

check_sum() {
  local md5
  generate_md5 "${!hib_key}"
  for g in "${game[@]}"; do
    ## store the md5 hash
    md5="$(md5sum <"${dir_hib}/$g")"
    ## md5sum has a really irritating habit to print "cksum   filename"
    ## strip everything from first space to end of var
    md5="${md5%% *}"
    sum="${cksums[$g]}"
    ## capitalize all the characters and match them
    ## can't guarantee mixed case will ever match
    ## capitalize everything, sums may be mixed case (i think)
    ## potential to result in flawed success?
    ## without case modification, potential for false negatives?
    sum="${sum^^}"
    md5="${md5^^}"
    if [[ "$md5" == "${sum}" ]]; then
      verbose "INFO" "The md5 for $g is okay!"
    else
      broken "Checksums did not match." ||
       verbose "INFO" "The md5 for $g ($md5) did not match $sum"
    fi
  done
}

hib_key="hibkey_$1"
check_files
check_key "$hib_key"
hib_bundle="$hib_key"
generate_list "${!hib_key}"
dl_game
(( check_md5 )) && check_sum
