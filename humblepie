#!/usr/bin/env bash
###############################################################################
### thanks to:
### JavaAtom <faustian.merula@gmail.com>: filename generation for Introversion
### kevlarman <>: filenames for hib 1, 2
###
###############################################################################
## covered bundles:
##  4, 5, frozensynapse, introversion/1/2(maybe?)

rchome="${XDG_CONFIG_HOME}/humblepie"
if (( EUID == 0 )); then
  printf "%s%s\n\t%s"  "You are running this script as root! " \
    "This is potentially dangerous!" \
    "Continue? (y/N): "
  read -r rootreply
  [[ "$rootreply" =~ "[yY]??" ]] &&
   ## if they want to continue, test for $rcfile
    [[ ! -f "$rcfile" ]] && 
    ## if it's not there, we're going to use /etc instead
    ## they're already root at this point, so further checking is moot
      rchome="/etc/humblepie"
fi

rcfile="$rchome/humblepie.rc"
[[ -d "$rchome" ]] || mkdir -p "$rchome"
if [[ -r "$rcfile" ]]; then
  . "$rcfile"
elif [[ -f "$rcfile" ]]; then
  echo "Bad permissions on $rcfile!"
else
  echo "No config file detected!"
fi

## check for automagic, turn on verbosity by default
(( automagic )) && verbose=1

## if verbose is on, define verbose(). if off, define broken()
## this way, testing for verbose is only done a single time
## probably a better way to do this, but we'll get around to it later
if (( verbose )); then
  ## i would like to incorporate some gettext action in here
  printf "%s\n\t%s\n\t%s\n" "Verbose reporting is on!" \
    "Run this program again with -x no and -v no to turn it off." \
    "Alternatively, use $rcfile to pre-configure all settings"

  verbose() {
      local info="$1"; shift
      printf "%s\t%s\n" "==> $(gettext "$info": "$@")"
  } >&2
  ## probably unnecessary to do
  broken() { : } &>/dev/null
else
  broken() {
    local info="$1"; shift
    printf "%s\n\t%s\n" "==> $(gettext "Something is wrong"...)" \
      "$(gettext "Try again with -v\n" "PROBLEM: $info" "$@")"
    return 1
  } >&2
  ## again, likely unnecessary
  verbose() { : } &>/dev/null
fi

check_key() {
  ## this needs to be opened up a bit to check keys manually specified on cli
  ## probably just accept $1, in fact that's what i'll do now
  ## so send "${!hib_bundle}" or the key from cli
  ## TODO: now figure out why i am verifying a key from cli
  ## those should only be specified because not in config yet
  # local k="${!hib_bundle}"
  local k="$1"
  local ret=0
  ## verify a key was sent, if empty cry about it
  [[ -z "$k" ]] && {
    broken "Unspecified key."
    verbose "ERROR" "hib_bundle is not specified.\n" \
      "\tSpecify the bundle you would like to use with -b [bundle]"
    ret=1
  }
  ## now loop through the keys and when a match is found, set hib_key
  ## only 1 key can be specified at a time
  ## only 1 match is ever possible
  for v in "${!bundlekeys[@]}"; do
    [[ "$v" == "$k" ]] && {
      hib_key="$v"
      ## i break just to end the loop as early as possible
      break
    }
    ret=2
  done
}

check_arch() {
  local arch="$1"
  ## make sure hib_arch is set; then...
  if [[ -n "$arch" ]]; then
    ## ensure its value is legal in my context or cry about it
    [[ "$arch" =~ "i.86" || "$arch" == "x86_64" ]] || {
      broken "Bad architecture."
      verbose "WARNING" "Invalid value for hib_arch.\n" \
        "\tValid values are i386, i686, x86_64" \
        "\t\`uname -m\` should return the correct information."

      ## TODO: find a better way to do the automagic things
      ## probably similar to the way we do verbose

      ## if automagic is on, set hib_arch to something i expect
      if (( automagic )); then
        hib_arch="$(uname -m)"
        verbose "INFO" "Using $hib_arch instead..."
      fi
    }
  else 
    ## so they never set hib_arch
    broken "Unspecified architecture."
    verbose "WARNING" "Architecture has not been specified.\n" \
      "\tPlease specify it with -a \`uname -m\`"

    ## TODO: can i combine this together somehow?

    ## but i can still try to set it to something sane
    (( automagic )) && {
      hib_arch="$(uname -m)"
      verbose "INFO" "Using $hib_arch instead..."
    }
  fi
}

check_dir() {
  ## grab 1st arg
  local d="$1"
  ## make sure it's a directory
  if [[ -d "$d" ]]; then
    ## make sure it is writable, or cry about it
    [[ -w "$d" ]] || {
      broken "Bad directory."
      verbose "ERROR" "$d does not exist or is not writable!"
      ##if automagic, and current dir is writable, use it
      if (( automagic )) && [[ -w "$PWD"]]; then

        ## TODO: does this need to be a case?

        case "$d" in
          hib_dir)
            hib_dir="$PWD/humbleindiebundle/"
            verbose "INFO" "Using $hib_dir instead..."
            d="hib_dir"
            ;;
          hib_torrent_dir)
            hib_torrent_dir="$PWD/humbleindiebundle/torrents/"
            verbose "INFO" "Using $hib_torrent_dir instead..."
            d="hib_torrent_dir"
            ;;
          *)
            verbose "ERROR" "$d should only be hib_dir or hib_torrent_dir!"
            return 1
            ;;
        esac
        mkdir -p "${!d}"
      fi
    }
  else
    broken "Unspecified directory."
    verbose "WARNING" "No download directory specified.\n" \
      "\tUsing current directory instead..."

    ## TODO: is this really necessary? should i set both dirs to this?
    ## maybe do it if automagic is on

    directory="$PWD"
  fi
}

get_uri() {
  ## TODO: generate link from this
  ## takes hib_game and hib_key, slots it into link to get valid downloads
  local game="$1"
  local key="$2"
  # uri="$(curl -s http://www.humblebundle.com/downloads?key="${!hib_key}" \
  local list="$key.txt"
  if [[ -n "$use_torrent" ]]; then
    ## this is index.html of the downloads page for specified key
  fi
}

get_list() {
  local k="$1"
  ## trying to save these files to avoid redownloading
  ## this is a list of raw filenames and should be grabbed in 2 cases:
  ## if this file does not already exist, grab it
  ## if the updater is run, grab all the files again
  ## clobber this file, the old version is always useless

  ## quick and dirty way to grab a complete list of files
  lynx -dump http://www.humblebundle.com/downloads?key="$k" |
    grep files|grep -v webseed|cut -d'/' -f4|cut -d'?' -f1>"$k.txt"
}

download_file() {
  ## new try at downloading
  # download command
  local dlcmd="$1"
  # URL of the file
  local url="$2"
  # destination file
  local file="$3"
  # temporary download file, default to last component of the URL
  # but the last component isn't always the real file!
  # local dlfile="${url##*/}"

  # replace %o by the temporary dlfile if it exists
  if [[ $dlcmd = *%o* ]]; then
    dlcmd=${dlcmd//\%o/\"$file.part\"}
    dlfile="$file.part"
  fi
  # add the URL, either in place of %u or at the end
  if [[ $dlcmd = *%u* ]]; then
    dlcmd=${dlcmd//\%u/\"$url\"}
  else
    dlcmd="$dlcmd \"$url\""
  fi

  local ret=0
  eval "$dlcmd || ret=\$?"
  if (( ret )); then
    [[ ! -s "$dlfile" ]] && rm -f -- "$dlfile"
    return $ret
  fi

  # rename the temporary download file to the final destination
  if [[ $dlfile != "$file" ]]; then
    mv -f "$SRCDEST/$dlfile" "$SRCDEST/$file"
  fi
}


check_sum() {
  ## verify how to use md5sum properly to prevent printing filename or `-'
  local g="$1"
  ## if checksumming is enabled, then...
  if (( check_sum )); then
    ## set the md5sum (md5sum prints the filename too, need to quiet it =\)
    hib_game_md5sum="$(md5sum "$g")"
    ## TODO: generate "${hib_md5[@]}"
    ## verify the new md5 against the md5 array or cry about it
    [[ "$hib_game_md5sum" == "${hib_md5[$g]" ]] || {
      broken "MD5 did not match."
      verbose "ERROR" "$hib_game_md5sum does not match ${hib_md5[$g]}"
    }
    verbose "INFO" "$hib_game_md5sum == ${hib_md5[$g]}"
    verbose "INFO" "MD5 for $g was correct."
  fi
}

# vim: ft=sh sw=2 sts=2 et
