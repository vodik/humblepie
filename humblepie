#!/usr/bin/env bash
# vim: ft=sh sw=2 sts=2 et
###############################################################################
### thanks to:
### JavaAtom <faustian.merula@gmail.com>: filename generation for Introversion
### kevlarman <>: filenames for hib 1, 2
###
###############################################################################
## covered bundles:
##  4, 5, frozensynapse, introversion/1/2(maybe?)

## comments starting with a single octothorpe are experimental code
## more than one octothorpe signifies detail or instructional comments
dir_rc="${XDG_CONFIG_HOME}/humblepie"

(( ! EUID )) && {
  ## check if they used root on purpose
  if  (( ! asroot )); then
    automagic=0
    ## if expected $rcfile doesn't exist, we're going to use /etc instead
    ## they're already root at this point, so further checking is moot
    [[ -f "${dir_rc}/humblepie.rc" ]] || dir_rc="/etc/humblepie"
  fi
}

asroot="${asroot:=0}"
automagic="${automagic:+0}"
check_key="${check_key:=1}"
md5prog="${md5prog:=md5sum}"
verbose=${verbose:-1}

## really need to figure this bitch out
## i have to set rcfile after verifying the directory is okay
## how about in the check_dir(), just set the bastard
## i intend to run check_dir() for _every_ invocation
rcfile="$dir_rc/humblepie.rc"
if [[ -r "$rcfile" ]]; then
  . "$rcfile"
elif [[ -f "$rcfile" ]]; then
  echo "Bad permissions on $rcfile!"
else
  echo "No config file detected!"
fi

## make gettext() a no-op if the binary is not executable
[[ ! -x "$(type -p gettext)" ]] && gettext() { echo "$@"; }
## if automagic is enabled let's setup a passthrough function
## check for automagic, turn on verbosity by default
if (( automagic )); then verbose=1; automage() { :; } 
else automagic() { false; } &>/dev/null; fi
## if verbose is on, define verbose(). if off, define broken()
## this way, testing for verbose is only done a single time
## probably a better way to do this, but we'll get around to it later
if (( verbose )); then
  ## i would like to incorporate some gettext action in here
  printf "%s\n\t%s\n\t%s\n" "Verbose reporting is on!" \
    "Run this program again with -x and -v to turn it off." \
    "Alternatively, use $rcfile to pre-configure for $USER."

  verbose() {
    ## verbose has no special return value associated with it
    ## sometimes we call it to print extra info
    ## sometimes it prints errors. return accordingly
    ## WARNING: return 2; ERROR: return 1; else return 0
    local info="$1"; shift
    printf "%s\t%s\n" "==> $(gettext "$info":)" "$@"
  } >&2
  ## define this as false so i can do `broken && cmd` and cmd..
  ## .. only executes if verbose() { false; }; otherwise..
  ## .. i can do `broken || cmd` if necessary
  ## probably unnecessary to do
  broken() { false; } &>/dev/null
else
  broken() {
    ## broken() always returns 1 because we _probably_ want to exit 
    local mess="$1"; shift
    printf "%s\n\t%s\n" "==> $(gettext Something is wrong...)" \
      "Try again with -v\n" "PROBLEM: $mess" "$@"
    return 1
  } >&2
  ## same applies here as did to broken() { false; }
  ## again, likely unnecessary
  verbose() { false; } &>/dev/null
fi

inarray() {
  local n="$1" a="$2"; shift 2
  for $a; do 
    [[ "$n" == "$a" ]] && return
  done
  return 1
}

check_key() {
  ## grab the key
  # local k="$1" ret=0
  ## declare the array for keys
  declare -A bundlekeys
  ## expand all $hibkey_* variables from rcfile if they are set
  ## the quotes and @ are important for proper expansion
  for var in "${!hibkey_@}"; do
    ## this is an indirect expansion to test if any $hibkey_* expanded
    ## ${!var} will equal the value of each $hibkey_* in turn
    ## if hibkey_foo="barbazquux" then $var expands to "barbazquux"
    ## $var would be "hibkey_foo"
    ## ["hibkey_foo"]="barbazquux"
    # bundlekeys+=( ["${var##*_}"]="${var}" ) 
    # if [[ ${!bundlekeys@} ]]; then
    ## only populate array if there is a key defined
    [[ "${!var}" == "${!hib_key}" ]] || {
      ## if no key found, cry
      broken "No keys discovered."
      verbose "ERROR" "No keys configured.\n" \
        "\tPlease specify a key with -k [key] or in your user's config file."
      return 1
    }
    k="${var}"
    h="${var##*_}"
    bundlekeys+=(["$k"]="$h") 
  # exit
  done
  verbose "INFO" "${#bundlekeys[@]} key found!"
}

## i think this can be rewritten with non-short-circuit ;;& case
check_dir() {
  local d
  ## loop over args, we'll just call this 1 time per run
  for d in "$@"; do
  ## make sure it's a directory
    if [[ -d "$d" ]]; then
      ## make sure it is r/w, or cry about it
      [[ -r "$d" && -w "$d" ]] || {
        broken "Bad directory." ||
          verbose "ERROR" "$d does not exist or you lack permissions!"
        ## if automagic, and current dir is writable, use it
         automagic && {
         [[ -r "$PWD" && -w "$PWD" ]] || {
          broken "$PWD is not r/w." || { 
            verbose "ERROR" \
              "$PWD must be r/w to enable automagic to continue.\n" \
              "\tRun this script in a directory you have permissions in, " \
              "or setup your config file appropriately."
            return 1
            }
          ## $d will be one of these at a time
          ## case will find this setting and convert $d to the one i need
          ## when a match is found, the case ends for this iteration of loop
          case "${!dir_@}" in
            dir_hib)
              d="$PWD/humbleindiebundle/"
              verbose "INFO" "Using $dir_hib instead..."
              dir_hib="$d"
              ;;&
            dir_hib_torrent)
              d="$PWD/humbleindiebundle/torrents/"
              dir_hib_torrent="$d"
              verbose "INFO" "Using $dir_hib_torrent instead..."
              ;;&
            dir_rc)
              d="$PWD/humblepie"
              dir_rc="$d"
              verbose "INFO" "Using $dir_rc instead..."
              rcfile="$dir_rc/humblepie.rc"
              # [[ -f "$rcfile" ]] ||
              ;;
            *)
              verbose "ERROR" "Pass a proper value for \$d."
              return 1
              ;;
          esac
          ## $d does not get clobbered because the loop runs fully per arg
          ## and case short-circuits at the first match
          for dir in "${!dir_@}"; do
            [[ "${dir}" ]] || mkdir -p "$dir" 
          done
          }
        }
      }
    else
      broken "Unspecified directory." ||
        verbose "ERROR" "No download directory specified."
      return 1
    fi
done
}

check_sum() {
  local game="$1"
  local list="$2"
  md5="$("$md5prog" <"$game")"
  ## md5sum has a really irritating habit to print "cksum   filename"
  ## strip everything from first space to end of var
  md5="${md5%% *}"
  while read -r sum; do
    ## capitalize all the characters and match them
    ## can't guarantee mixed case will ever match
    ## capitalize everything, sums may be mixed case (i think)
    ## potential to result in flawed success?
    [[ "${md5^^}" == "${sum^^}" ]] && return
  done <$list
  broken "No matching md5 checksum." ||
    verbose "WARNING" "The md5 checksum for the game did not match " \
      "any checksums in $list.\n" \
      "\tVerify it manually or try updating it with -U."
}

generate_list() {
  ## send the value of the chosen $hibkey_*; the rest is automagic
  local key="$1"
  local prefix="${USER}-${hib_bundle}-${key}"
  local dump="${prefix}-dump.txt"

  links -html-numbered-links 1 \
    -dump https://www.humblebundle.com/downloads\?key\="${key}" >$dump

  declare -a list
  ## generate the array as a list of game filenames
  while read -r line; do
    list+=("$line")
  done <$dump

  declare -Ag newlist
  for a in "${list[@]}"; do
    ## i want every element that matches *files*/ ...
    b="${a##*files*/}"
    [[ $b == "$a" ]] || {
      ## and then from those, strip ?key=* out of the end
      c="${b%%?key*}"
      ## and finally, everything from &t= onward is the md5sum, weird
      d="${b##*t=}"
      ## dump it into an associative array to get games by name
      newlist+=(["$c"]="$d")
    }
  done
  ## now build another array to complete the reference loop
  ## this array is designed to assign 1-N to game filenames
  ## then present the user with the printf, and when they input 1...
  ## ...i use ${userlist[1]} to get the game's filename
  local num=1
  declare -ag userlist
  set -x
  for f in "${!newlist[@]}"; do
    userlist[$num]="$f" || exit 1
    # printf '%s\t%s\t%s\n' "$num" "$f" "${newlist[$f]}"
    printf '%s\t%s\t%s\n' "$num" "${userlist[$f]}" "${!userlist[$f]}"
    ((num++))
  done
  exit
}

dl_game() {
  set -x
  printf '%s' "Choose game: "
  while read -r game; do
  curl -o "${hib_dir}/${userlist[$game]}" \
    "https://files.humblebundle.com/${userlist[$game]}?key=${!hib_key}&t=${newlist[$game]}" || break
  done
}

hib_key="hibkey_$1"
check_key "$hib_key"
hib_bundle="${hib_key}"
check_dir "$dir_hib" "$dir_hib_torrent" "$dir_rc"
cd "$dir_hib"
generate_list "${!hib_key}"
dl_game
