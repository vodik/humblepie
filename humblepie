#!/usr/bin/env bash
# vim: ft=sh sw=2 sts=2 et
###############################################################################
### thanks to:
### JavaAtom <faustian.merula@gmail.com>: filename generation for Introversion
### kevlarman <>: filenames for hib 1, 2
###
###############################################################################
## covered bundles:
##  4, 5, frozensynapse, introversion/1/2(maybe?)

asroot=0
automagic=0
hib_check_key=1
verbose=0
rcdir="${XDG_CONFIG_HOME}/humblepie"

(( ! EUID )) && {
  ## check if they used root on purpose
  if  (( ! asroot )); then
    ## if $rcfile doesn't exist, we're going to use /etc instead
    ## they're already root at this point, so further checking is moot
    [[ ! -f "$rcfile" ]] && rcdir="/etc/humblepie"
  fi
}

rcfile="$rcdir/humblepie.rc"
## i should be able to send this to check_dir()
# [[ -d "$rcdir" ]] || mkdir -p "$rcdir"
if [[ -r "$rcfile" ]]; then
  . "$rcfile"
elif [[ -f "$rcfile" ]]; then
  echo "Bad permissions on $rcfile!"
else
  echo "No config file detected!"
fi

## brilliant idea, if gettext doesn't exist just echo the args
## makepkg is some fantastic inspiration even if it's ugly
if [[ ! -x "$(type -p gettext)" ]]; then
  gettext() {
    echo "$@"
  }
## check for automagic, turn on verbosity by default
(( ! automagic )) && verbose=1

## if verbose is on, define verbose(). if off, define broken()
## this way, testing for verbose is only done a single time
## probably a better way to do this, but we'll get around to it later
if (( ! verbose )); then
  ## i would like to incorporate some gettext action in here
  printf "%s\n\t%s\n\t%s\n" "Verbose reporting is on!" \
    "Run this program again with -x no and -v no to turn it off." \
    "Alternatively, use $rcfile to pre-configure for $USER."

  verbose() {
    ## verbose has no special return value associated with it
    ## sometimes we call it to print extra info
    ## sometimes it prints errors. return accordingly
    ## WARNING: return 2; ERROR: return 1; else return 0
    local info="$1"; shift
    printf "%s\t%s\n" "==> $(gettext "$info": "$@")"
  } >&2
  ## define this as false so i can do `broken && cmd` and cmd..
  ## .. only executes if verbose() { false; }; otherwise..
  ## .. i can do `broken || cmd` if necessary
  ## probably unnecessary to do
  broken() { false; } &>/dev/null
else
  broken() {
    ## broken() always returns 1 because we _probably_ want to exit 
    local mess="$1"; shift
    printf "%s\n\t%s\n" "==> $(gettext "Something is wrong..." \
      "Try again with -v\n" "PROBLEM: $mess" "$@")"
    return 1
  } >&2
  ## again, likely unnecessary
  verbose() { false; } &>/dev/null
fi

check_key() {
  ## grab the key
  # local k="$1" ret=0
  ## declare the array for keys
  declare -A bundlekeys
  ## expand all $hibkey_* variables from rcfile if they are set
  ## the quotes and @ are important for proper expansion
  for var in "${!hibkey_@}"; do
    ## this is an indirect expansion to test if any $hibkey_* expanded
    ## ${!var} will equal the value of each $hibkey_* in turn
    ## if hibkey_foo="barbazquux" then ${!var} expands to "barbazquux"
    ## $var would be "hibkey_foo
    ## only populate array if there is a key defined
    if [[ -n ${!var} ]]; then
      ## ["hibkey_foo"]="barbazquux"
      bundlekeys+=( ["$var"]="${!var}" ) 
      verbose "INFO" "Key ${!var} for $var found."
    else 
      ## if no key found, cry
      broken "No keys discovered." ||
        verbose "ERROR" "No keys configured.\n" \
          "Please specify a key with -k [key] or in your user's config file."
    fi
  done
}

check_arch() {
  local arch="$1"
  ## make sure hib_arch is set; then...
  if [[ -n "$arch" ]]; then
    ## ensure its value is legal in my context or cry about it
    [[ "$arch" =~ "i.86" || "$arch" == "x86_64" ]] || {
      broken "Bad architecture." ||
        verbose "WARNING" "Invalid value for hib_arch.\n" \
          "\tValid values are i386, i686, x86_64" \
          "\t\`uname -m\` should return the correct information."

      ## TODO: find a better way to do the automagic things
      ## probably similar to the way we do verbose

      ## if automagic is on, set hib_arch to something i expect
      if (( ! automagic )); then
        hib_arch="$(uname -m)"
        verbose "INFO" "Using $hib_arch instead..."
      fi
    }
  else 
    ## so they never set hib_arch
    broken "Unspecified architecture." ||
      verbose "ERROR" "Architecture has not been specified.\n" \
        "\tPlease specify it with -a \`uname -m\`"

    ## but i can still try to set it to something sane
    if (( ! automagic )); then
      hib_arch="$(uname -m)"
      verbose "INFO" "Using $hib_arch instead..."
    else return 2
    fi

  fi
}

check_dir() {
  local d
  ## loop over args, we'll just call this 1 time per run
  for d in "$@"; do
  ## make sure it's a directory
    if [[ -d "$d" ]]; then
      ## make sure it is r/w, or cry about it
      [[ -r "$d" && -w "$d" ]] || {
        broken "Bad directory." ||
          verbose "ERROR" "$d does not exist or you lack permissions!"
        ## if automagic, and current dir is writable, use it
        if (( ! automagic )) && [[ -r "$PWD" &&  -w "$PWD"]]; then

          ## TODO: does this need to be a case?
          ## NOTE: probably, i'm trying to check more dirs

          ## TODO: find out if this should be indirect, it's obtuse
          case "${!d}" in
            hib_dir)
              dir_hib="$PWD/humbleindiebundle/"
              verbose "INFO" "Using $dir_hib instead..."
              d="dir_hib"
              ;;
            hib_torrent_dir)
              hib_torrent_dir="$PWD/humbleindiebundle/torrents/"
              verbose "INFO" "Using $hib_torrent_dir instead..."
              d="dir_torrent_hib"
              ;;
            rcdir)
              dir_rc="$PWD/humblepie"
              verbose "INFO" "Using $rcdir instead..."
              d="dir_rc"
              ;;
            *)
              verbose "ERROR" "Pass a proper value for \$d."
              return 1
              ;;
          esac
          mkdir -p "${!d}"
        fi
      }
    else
      broken "Unspecified directory." ||
        verbose "WARNING" "No download directory specified.\n" \
          "\tUsing current directory instead..."

      ## TODO: is this really necessary? should i set both dirs to this?
      ## maybe do it if automagic is on

      directory="$PWD"
    fi
done
}

get_uri() {
  ## TODO: generate link from this
  ## takes hib_game and hib_key, slots it into link to get valid downloads
  local game="$1"
  local key="$2"
  # uri="$(curl -s http://www.humblebundle.com/downloads?key="${!hib_key}" \
  local list="$key.txt"
  if [[ -n "$use_torrent" ]]; then
    ## this is index.html of the downloads page for specified key
  fi
}

get_list() {
  local k="$1"
  ## trying to save these files to avoid redownloading
  ## this is a list of raw filenames and should be grabbed in 2 cases:
  ## if this file does not already exist, grab it
  ## if the updater is run, grab all the files again
  ## clobber this file, the old version is always useless

  ## quick and dirty way to grab a complete list of files
  links -html-numbered-links 1 \
    -dump http://www.humblebundle.com/downloads?key="$k" |
    grep files|grep -v webseed|cut -d'/' -f4|cut -d'?' -f1>"$k.txt"
}

check_sum() {
  local game="$1"
  local list="$2"
  md5="$(md5sum "$1")"
  grep "$md5" "$list" || return 2
}

